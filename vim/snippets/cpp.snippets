#
# include
#

snippet inc "include" bA
#include <${1:iostream}>$0
endsnippet

snippet inf "include from file" bA
#include "$1"$0
endsnippet

snippet ia "include algorithm"
#include <algorithm>
endsnippet

snippet iv "include vector"
#include <vector>
endsnippet

snippet is "include set"
#include <set>
endsnippet

snippet iq "include queue"
#include <queue>
endsnippet

#
# function
#

snippet mn "main no arguments" bA
int main()
{
	$0
}
endsnippet

snippet nl "newline"
putchar('\n');$0
endsnippet

snippet r "reverse"
std::reverse($1.begin(), $1.end());$0
endsnippet

snippet fu "function" bA
${1:void} ${2:name}($3){
	$4
}$0
endsnippet

snippet la "lambda function"
auto $1 = [$2]($3) {
	$4
};$0
endsnippet

snippet so "sort"
std::sort($1.begin(), $1.end()${2:, std::greater<$3>()});$0
endsnippet

#
# type
#

snippet stru "struct"
struct $1{
	$2
};$0
endsnippet

snippet v "vector" b
std::vector <$1> $0
endsnippet

snippet se "set"
std::set <$1> $0
endsnippet

snippet pa "pair"
std::pair <$1,$2> $0
endsnippet

snippet stri "string"
std::string $0
endsnippet

snippet pq "priority queue"
std::priority_queue<$1,${2: ${3:std::vector<$1>},${4:std::greater<$1>}}> $5;$0
endsnippet

snippet llo "long long" iA
long long $0
endsnippet

snippet st "struct"
struct $1 {
	$2
};$0
endsnippet

#
# io
#

# TODO Use function in cii and cill
snippet "cin?" "cin" r
std::cin >> $0
endsnippet

snippet "co(ut?)?" "cout" r
std::cout << $0
endsnippet

snippet cia "cin to array"
for(int i = 0; i < $1; i++) {
	std::cin >> $2[i];
}$0
endsnippet

snippet cii "cin to int"
int $1;
std::cin`!p
args = [x for x in t[1].split(',')]
if args:
	for arg in args:
		snip.rv += " >> %s" % (arg)`;$0
endsnippet

snippet cis "cin to string"
std::string $1;
std::cin`!p
args = [x for x in t[1].split(',')]
if args:
	for arg in args:
		snip.rv += " >> %s" % (arg)`;$0
endsnippet

snippet civ "cin to vector" A
std::vector<$1> $2($3);
for (int i = 0; i < $3; i++) {
	std::cin >> $2[i];
}
endsnippet

snippet civv "cin to two-array vector"
std::vector<std::vector<$1>> $2($3, std::vector<$1>($4));
for (int i = 0; i < $3; i++) {
	for (int j = 0; j < $4; j++) {
		std::cin >> $2[i][j];
	}
}
endsnippet

snippet cill "cin to long long" A
long long $1;
std::cin`!p
args = [x for x in t[1].split(',')]
if args:
	for arg in args:
		snip.rv += " >> %s" % (arg)`;$0
endsnippet

snippet ov "output vector" A
std::for_each($1.begin(), $1.end(), [](auto t){
	std::cout << t << std::endl;
});$0
endsnippet

#
# if statement
#

snippet if "if statement"
if ($1) {
	$2
}$0
endsnippet

snippet ie "if else"
if ($1) {
	$2
} else {
	$3
}$0
endsnippet

#
# loop
#

snippet w "while" b
while ($1) {
	$2
}$0
endsnippet

snippet f0 "for i=0 i<xxx i++" bA
for (int $1 = 0; $1 < $2; $1++){
	$3
}$0
endsnippet

snippet fo "general for snip"
for (int $1 = $2; $1 < $3; $1++){
	$4
}$0
endsnippet

snippet fe "for with equal"
for (int $1 = $2; $1 <= $3; $1++){
	$4
}$0
endsnippet

snippet fa "for auto"
for (auto $1 : $2){
	$3
}$0
endsnippet

snippet fn "for negative way"
for (int $1 = $2; $1 >= $3; $1--){
	$4
}$0
endsnippet

#
# others
#

snippet "^de" "define" rA
#define $0
endsnippet

snippet ret "return" A
return $0
endsnippet

snippet mod "mod 10**9 + 7"
const int mod = 1000000007;$0
endsnippet

snippet sumq "sum of queue"
while ($1.size()) {
	$2 += $1.top();
	$1.pop();
}$0
endsnippet

#
# .h file
#

snippet hdef "header define" bA
#ifndef $1
#define $1
$0
#endif
endsnippet

#
# competitive programming
#

snippet comp "competitive programming" bA
#include <algorithm>
#include <climits>
#include <cmath>
#include <iostream>
#include <numeric>
#include <queue>
#include <unordered_map>
#include <vector>
#include <map>

const int mod = 1e9 + 7;
const int kmax = 510000;

long long fact[kmax], fact_inv[kmax], inv[kmax];

void init_comb()
{
	fact[0] = fact[1] = 1;
	fact_inv[0] = fact_inv[1] = 1;
	inv[1] = 1;
	for (int i = 2; i < kmax; i++) {
		fact[i] = fact[i - 1] * i % mod;
		inv[i] = mod - inv[mod % i] * (mod / i) % mod;
		fact_inv[i] = fact_inv[i - 1] * inv[i] % mod;
	}
}

long long comb(int n, int r)
{
	if (n < r) {
		return 0;
	}

	if (n < 0 || r < 0) {
		return 0;
	}

	return fact[n] * (fact_inv[r] * fact_inv[n - r] % mod) % mod;
}

template <typename T, T N>
class UnionFind {
	T parent_[N];
	T rank_[N];
	T size_[N];

public:
	UnionFind();
	T Root(T idx);
	bool IsSame(T x, T y);
	void Unite(T x, T y);
	T GetSize(T idx);
};

template <typename T, T N>
UnionFind<T, N>::UnionFind()
{
	for (T i = 0; i < N; i++) {
		parent_[i] = i;
		rank_[i] = 0;
		size_[i] = 1;
	}
}

template <typename T, T N>
T UnionFind<T, N>::Root(T idx)
{
	return parent_[idx] == idx ? idx : parent_[idx] = Root(parent_[idx]);
}

template <typename T, T N>
bool UnionFind<T, N>::IsSame(T x, T y)
{
	return Root(x) == Root(y);
}

template <typename T, T N>
void UnionFind<T, N>::Unite(T x, T y)
{
	x = Root(x);
	y = Root(y);
	if (x == y) {
		return;
	}

	if (rank_[x] < rank_[y]) {
		parent_[x] = y;
		size_[y] += size_[x];
	} else {
		parent_[y] = x;
		size_[x] += size_[y];
		if (rank_[x] == rank_[y]) {
			rank_[x]++;
		}
	}
}

template <typename T, T N>
T UnionFind<T, N>::GetSize(T idx)
{
	return size_[Root(idx)];
}

long long pow_mod(long long n, long long p, long long m)
{
	if (p == 0) {
		return 1;
	}

	if (p % 2 == 0) {
		long long t = pow_mod(n, p / 2, m);
		return t * t % m;
	}
	return n * pow_mod(n, p - 1, m) % mod;
}

long long nCr_mod(long long n, long long r)
{
	long long x = 1;
	for (long long i = n - r + 1; i <= n; i++) {
		x *= i;
		x %= mod;
	}

	long long a = 1;
	for (long long i = 1; i <= r; i++) {
		a *= i;
		a %= mod;
	}

	long long y = pow_mod(a, mod - 2, mod) % mod;

	return x * y % mod;
}

bool is_prime(long long n)
{
	if (n == 1) {
		return false;
	}

	for (long long i = 2; i * i <= n; i++) {
		if (n % i == 0) {
			return false;
		}
	}

	return true;
}


int main()
{
	$0
}

endsnippet
